# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange

# -----------------------------------------------------------------------------

try:
    basestring  # Python 3
except NameError:
    basestring = str  # Python 2
import hashlib
import math
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import AccountSuspended
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import OrderNotCached
from ccxt.base.errors import CancelPending
from ccxt.base.errors import NotSupported
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import InvalidNonce
from ccxt.base.errors import RequestTimeout


class poloniex (Exchange):

    def describe(self):
        return self.deep_extend(super(poloniex, self).describe(), {
            'id': 'poloniex',
            'name': 'Poloniex',
            'countries': ['US'],
            'rateLimit': 1000,  # up to 6 calls per second
            'has': {
                'createDepositAddress': True,
                'fetchDepositAddress': True,
                'CORS': False,
                'editOrder': True,
                'createMarketOrder': False,
                'fetchOHLCV': True,
                'fetchOrderTrades': True,
                'fetchMyTrades': True,
                'fetchOrderBooks': True,
                'fetchOrder': 'emulated',
                'fetchOrders': 'emulated',
                'fetchOpenOrders': True,
                'fetchClosedOrders': 'emulated',
                'fetchTickers': True,
                'fetchTradingFees': True,
                'fetchCurrencies': True,
                'withdraw': True,
                'fetchTransactions': True,
                'fetchWithdrawals': 'emulated',  # but almost True )
                'fetchDeposits': 'emulated',
            },
            'timeframes': {
                '5m': 300,
                '15m': 900,
                '30m': 1800,
                '2h': 7200,
                '4h': 14400,
                '1d': 86400,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg',
                'api': {
                    'public': 'https://poloniex.com/public',
                    'private': 'https://poloniex.com/tradingApi',
                },
                'www': 'https://poloniex.com',
                'doc': [
                    'https://poloniex.com/support/api/',
                    'http://pastebin.com/dMX7mZE0',
                ],
                'fees': 'https://poloniex.com/fees',
            },
            'api': {
                'public': {
                    'get': [
                        'return24hVolume',
                        'returnChartData',
                        'returnCurrencies',
                        'returnLoanOrders',
                        'returnOrderBook',
                        'returnTicker',
                        'returnTradeHistory',
                    ],
                },
                'private': {
                    'post': [
                        'buy',
                        'cancelLoanOffer',
                        'cancelOrder',
                        'closeMarginPosition',
                        'createLoanOffer',
                        'generateNewAddress',
                        'getMarginPosition',
                        'marginBuy',
                        'marginSell',
                        'moveOrder',
                        'returnActiveLoans',
                        'returnAvailableAccountBalances',
                        'returnBalances',
                        'returnCompleteBalances',
                        'returnDepositAddresses',
                        'returnDepositsWithdrawals',
                        'returnFeeInfo',
                        'returnLendingHistory',
                        'returnMarginAccountSummary',
                        'returnOpenLoanOffers',
                        'returnOpenOrders',
                        'returnOrderTrades',
                        'returnTradableBalances',
                        'returnTradeHistory',
                        'sell',
                        'toggleAutoRenew',
                        'transferBalance',
                        'withdraw',
                    ],
                },
            },
            'wsconf': {
                'conx-tpls': {
                    'default': {
                        'type': 'ws',
                        'baseurl': 'wss://api2.poloniex.com',
                    },
                },
                'events': {
                    'ob': {
                        'conx-tpl': 'default',
                        'conx-param': {
                            'url': '{baseurl}',
                            'id': '{id}',
                        },
                    },
                },
            },
            # Fees are tier-based. More info: https://poloniex.com/fees/
            # Rates below are highest possible.
            'fees': {
                'trading': {
                    'maker': 0.001,
                    'taker': 0.002,
                },
                'funding': {},
            },
            'limits': {
                'amount': {
                    'min': 0.00000001,
                    'max': 1000000000,
                },
                'price': {
                    'min': 0.00000001,
                    'max': 1000000000,
                },
                'cost': {
                    'min': 0.00000000,
                    'max': 1000000000,
                },
            },
            'precision': {
                'amount': 8,
                'price': 8,
            },
            'commonCurrencies': {
                'AIR': 'AirCoin',
                'APH': 'AphroditeCoin',
                'BCC': 'BTCtalkcoin',
                'BDG': 'Badgercoin',
                'BTM': 'Bitmark',
                'CON': 'Coino',
                'GOLD': 'GoldEagles',
                'GPUC': 'GPU',
                'HOT': 'Hotcoin',
                'ITC': 'Information Coin',
                'PLX': 'ParallaxCoin',
                'KEY': 'KEYCoin',
                'STR': 'XLM',
                'SOC': 'SOCC',
                'XAP': 'API Coin',
            },
            'options': {
                'limits': {
                    'cost': {
                        'min': {
                            'BTC': 0.0001,
                            'ETH': 0.0001,
                            'XMR': 0.0001,
                            'USDT': 1.0,
                        },
                    },
                },
            },
            'exceptions': {
                'exact': {
                    'You may only place orders that reduce your position.': InvalidOrder,
                    'Invalid order number, or you are not the person who placed the order.': OrderNotFound,
                    'Permission denied': PermissionDenied,
                    'Connection timed out. Please try again.': RequestTimeout,
                    'Internal error. Please try again.': ExchangeNotAvailable,
                    'Order not found, or you are not the person who placed it.': OrderNotFound,
                    'Invalid API key/secret pair.': AuthenticationError,
                    'Please do not make more than 8 API calls per second.': DDoSProtection,
                    'Rate must be greater than zero.': InvalidOrder,  # {"error":"Rate must be greater than zero."}
                },
                'broad': {
                    'Total must be at least': InvalidOrder,  # {"error":"Total must be at least 0.0001."}
                    'This account is frozen.': AccountSuspended,
                    'Not enough': InsufficientFunds,
                    'Nonce must be greater': InvalidNonce,
                    'You have already called cancelOrder or moveOrder on self order.': CancelPending,
                    'Amount must be at least': InvalidOrder,  # {"error":"Amount must be at least 0.000001."}
                },
            },
        })

    def calculate_fee(self, symbol, type, side, amount, price, takerOrMaker='taker', params={}):
        market = self.markets[symbol]
        key = 'quote'
        rate = market[takerOrMaker]
        cost = float(self.cost_to_precision(symbol, amount * rate))
        if side == 'sell':
            cost *= price
        else:
            key = 'base'
        return {
            'type': takerOrMaker,
            'currency': market[key],
            'rate': rate,
            'cost': float(self.fee_to_precision(symbol, cost)),
        }

    def parse_ohlcv(self, ohlcv, market=None, timeframe='5m', since=None, limit=None):
        return [
            ohlcv['date'] * 1000,
            ohlcv['open'],
            ohlcv['high'],
            ohlcv['low'],
            ohlcv['close'],
            ohlcv['quoteVolume'],
        ]

    async def fetch_ohlcv(self, symbol, timeframe='5m', since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        if since is None:
            since = 0
        request = {
            'currencyPair': market['id'],
            'period': self.timeframes[timeframe],
            'start': int(since / 1000),
        }
        if limit is not None:
            request['end'] = self.sum(request['start'], limit * self.timeframes[timeframe])
        response = await self.publicGetReturnChartData(self.extend(request, params))
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def find_market(self, string):
        if self.markets is None:
            raise ExchangeError(self.id + ' markets not loaded')
        # isNumeric = '/^\d+$/'.test(string)
        # cannot transpile Number
        # isNumeric = not Number.isNaN( int(string) )
        # isNumeric = str(int(string)) == 'NaN'
        isNumeric = True
        if str(string) != string:
            string = str(string)
        i = 0
        for i in range(0, len(string)):
            c = string[i]
            if c == '0':
                continue
            if c == '1':
                continue
            if c == '2':
                continue
            if c == '3':
                continue
            if c == '4':
                continue
            if c == '5':
                continue
            if c == '6':
                continue
            if c == '7':
                continue
            if c == '8':
                continue
            if c == '9':
                continue
            isNumeric = False
            break
        if isNumeric is True:
            if string in self.markets_by_id2:
                return self.markets_by_id2[string]
        elif isinstance(string, basestring):
            if string in self.markets_by_id:
                return self.markets_by_id[string]
            if string in self.markets:
                return self.markets[string]
        return string

    def set_markets(self, markets, currencies=None):
        # Poloniex uses an additional index for its curreny pairs
        # id2 is string containing only numeric chars
        # Calling super(poloniex, self).setMArkets does not transpile...
        self.marketsById2 = self.index_by(markets, 'id2')
        self.markets_by_id2 = self.marketsById2
        return super(poloniex, self).set_markets(markets, currencies)
        # Cannot use map
        # values = Object.values(markets).map(market => self.deep_extend({
        #     'limits': self.limits,
        #     'precision': self.precision,
        #}, self.fees['trading'], market))
        # self.marketsById2 = self.index_by(markets, 'id2')
        # self.markets_by_id2 = self.marketsById2
        # self.markets = self.deep_extend(self.markets, self.index_by(values, 'symbol'))
        # self.marketsById = self.index_by(markets, 'id')
        # self.markets_by_id = self.marketsById
        # self.symbols = list(self.markets).sort(.keys())
        # self.ids = list(self.markets_by_id).sort(.keys())
        # if currencies:
        #     self.currencies = self.deep_extend(currencies, self.currencies)
        # else:
        #     baseCurrencies =
        #         values.filter(market => 'base' in market)
        #             .map market.baseNumericId if (market =>({
        #                 id: market.baseId or market.base,
        #                 numericId: (market.baseNumericId is not None) else None,
        #                 code: market.base,
        #                 precision: (market.precision.base or market.precision.amount) if market.precision else 8,
        #             }))
        #     quoteCurrencies =
        #         values.filter(market => 'quote' in market)
        #             .map market.quoteNumericId if (market =>({
        #                 id: market.quoteId or market.quote,
        #                 numericId: (market.quoteNumericId is not None) else None,
        #                 code: market.quote,
        #                 precision: (market.precision.quote or market.precision.price) if market.precision else 8,
        #             }))
        #     allCurrencies = baseCurrencies.concat(quoteCurrencies)
        #     groupedCurrencies = self.group_by(allCurrencies, 'code')
        #     currencies = list(groupedCurrencies.keys()).map(code =>
        #         groupedCurrencies[code].reduce((previous, current) =>
        #             previous if ((previous.precision > current.precision) else current), groupedCurrencies[code][0]))
        #     sortedCurrencies = self.sort_by(flatten(currencies), 'code')
        #     self.currencies = self.deep_extend(self.index_by(sortedCurrencies, 'code'), self.currencies)
        #}
        # self.currencies_by_id = self.index_by(self.currencies, 'id')
        # return self.markets

    async def fetch_markets(self):
        markets = await self.publicGetReturnTicker()
        keys = list(markets.keys())
        result = []
        for p in range(0, len(keys)):
            id = keys[p]
            market = markets[id]
            # id2 = str(market['id'])
            quote, base = id.split('_')
            base = self.common_currency_code(base)
            quote = self.common_currency_code(quote)
            symbol = base + '/' + quote
            minCost = self.safe_float(self.options['limits']['cost']['min'], quote, 0.0)
            precision = {
                'amount': 6,
                'price': 8,
            }
            result.append(self.extend(self.fees['trading'], {
                'id': id,
                'id2': str(market['id']),
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'active': True,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': math.pow(10, -precision['amount']),
                        'max': None,
                    },
                    'price': {
                        'min': math.pow(10, -precision['price']),
                        'max': None,
                    },
                    'cost': {
                        'min': minCost,
                        'max': None,
                    },
                },
                'info': market,
            }))
        return result

    async def fetch_balance(self, params={}):
        await self.load_markets()
        balances = await self.privatePostReturnCompleteBalances(self.extend({
            'account': 'all',
        }, params))
        result = {'info': balances}
        currencies = list(balances.keys())
        for c in range(0, len(currencies)):
            id = currencies[c]
            balance = balances[id]
            currency = self.common_currency_code(id)
            account = {
                'free': float(balance['available']),
                'used': float(balance['onOrders']),
                'total': 0.0,
            }
            account['total'] = self.sum(account['free'], account['used'])
            result[currency] = account
        return self.parse_balance(result)

    async def fetch_trading_fees(self, params={}):
        await self.load_markets()
        fees = await self.privatePostReturnFeeInfo()
        return {
            'info': fees,
            'maker': self.safe_float(fees, 'makerFee'),
            'taker': self.safe_float(fees, 'takerFee'),
            'withdraw': {},
            'deposit': {},
        }

    async def fetch_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        request = {
            'currencyPair': self.market_id(symbol),
        }
        if limit is not None:
            request['depth'] = limit  # 100
        response = await self.publicGetReturnOrderBook(self.extend(request, params))
        orderbook = self.parse_order_book(response)
        orderbook['nonce'] = self.safe_integer(response, 'seq')
        return orderbook

    async def fetch_order_books(self, symbols=None, params={}):
        await self.load_markets()
        request = {
            'currencyPair': 'all',
        }
        #
        #     if limit is not None:
        #         request['depth'] = limit  # 100
        #     }
        #
        response = await self.publicGetReturnOrderBook(self.extend(request, params))
        marketIds = list(response.keys())
        result = {}
        for i in range(0, len(marketIds)):
            marketId = marketIds[i]
            symbol = None
            if marketId in self.markets_by_id:
                symbol = self.markets_by_id[marketId]['symbol']
            else:
                quoteId, baseId = marketId.split('_')
                base = self.common_currency_code(baseId)
                quote = self.common_currency_code(quoteId)
                symbol = base + '/' + quote
            orderbook = self.parse_order_book(response[marketId])
            orderbook['nonce'] = self.safe_integer(response[marketId], 'seq')
            result[symbol] = orderbook
        return result

    def parse_ticker(self, ticker, market=None):
        timestamp = self.milliseconds()
        symbol = None
        if market:
            symbol = market['symbol']
        open = None
        change = None
        average = None
        last = self.safe_float(ticker, 'last')
        relativeChange = self.safe_float(ticker, 'percentChange')
        if relativeChange != -1:
            open = last / self.sum(1, relativeChange)
            change = last - open
            average = self.sum(last, open) / 2
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'high24hr'),
            'low': self.safe_float(ticker, 'low24hr'),
            'bid': self.safe_float(ticker, 'highestBid'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'lowestAsk'),
            'askVolume': None,
            'vwap': None,
            'open': open,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': change,
            'percentage': relativeChange * 100,
            'average': average,
            'baseVolume': self.safe_float(ticker, 'quoteVolume'),
            'quoteVolume': self.safe_float(ticker, 'baseVolume'),
            'info': ticker,
        }

    async def fetch_tickers(self, symbols=None, params={}):
        await self.load_markets()
        tickers = await self.publicGetReturnTicker(params)
        ids = list(tickers.keys())
        result = {}
        for i in range(0, len(ids)):
            id = ids[i]
            symbol = None
            market = None
            if id in self.markets_by_id:
                market = self.markets_by_id[id]
                symbol = market['symbol']
            else:
                quoteId, baseId = id.split('_')
                base = self.common_currency_code(baseId)
                quote = self.common_currency_code(quoteId)
                symbol = base + '/' + quote
                market = {'symbol': symbol}
            ticker = tickers[id]
            result[symbol] = self.parse_ticker(ticker, market)
        return result

    async def fetch_currencies(self, params={}):
        currencies = await self.publicGetReturnCurrencies(params)
        ids = list(currencies.keys())
        result = {}
        for i in range(0, len(ids)):
            id = ids[i]
            currency = currencies[id]
            # todo: will need to rethink the fees
            # to add support for multiple withdrawal/deposit methods and
            # differentiated fees for each particular method
            precision = 8  # default precision, todo: fix "magic constants"
            code = self.common_currency_code(id)
            active = (currency['delisted'] == 0) and not currency['disabled']
            result[code] = {
                'id': id,
                'code': code,
                'info': currency,
                'name': currency['name'],
                'active': active,
                'fee': self.safe_float(currency, 'txFee'),  # todo: redesign
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': math.pow(10, -precision),
                        'max': math.pow(10, precision),
                    },
                    'price': {
                        'min': math.pow(10, -precision),
                        'max': math.pow(10, precision),
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                    'withdraw': {
                        'min': currency['txFee'],
                        'max': math.pow(10, precision),
                    },
                },
            }
        return result

    async def fetch_ticker(self, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        tickers = await self.publicGetReturnTicker(params)
        ticker = tickers[market['id']]
        return self.parse_ticker(ticker, market)

    def parse_trade(self, trade, market=None):
        timestamp = self.parse8601(trade['date'])
        symbol = None
        base = None
        quote = None
        if (not market) and('currencyPair' in list(trade.keys())):
            currencyPair = trade['currencyPair']
            if currencyPair in self.markets_by_id:
                market = self.markets_by_id[currencyPair]
            else:
                parts = currencyPair.split('_')
                quote = parts[0]
                base = parts[1]
                symbol = base + '/' + quote
        if market is not None:
            symbol = market['symbol']
            base = market['base']
            quote = market['quote']
        side = trade['type']
        fee = None
        cost = self.safe_float(trade, 'total')
        amount = self.safe_float(trade, 'amount')
        if 'fee' in trade:
            rate = self.safe_float(trade, 'fee')
            feeCost = None
            currency = None
            if side == 'buy':
                currency = base
                feeCost = amount * rate
            else:
                currency = quote
                if cost is not None:
                    feeCost = cost * rate
            fee = {
                'type': None,
                'rate': rate,
                'cost': feeCost,
                'currency': currency,
            }
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': self.safe_string(trade, 'tradeID'),
            'order': self.safe_string(trade, 'orderNumber'),
            'type': 'limit',
            'side': side,
            'price': self.safe_float(trade, 'rate'),
            'amount': amount,
            'cost': cost,
            'fee': fee,
        }

    async def fetch_trades(self, symbol, since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'currencyPair': market['id'],
        }
        if since is not None:
            request['start'] = int(since / 1000)
            request['end'] = self.seconds()  # last 50000 trades by default
        trades = await self.publicGetReturnTradeHistory(self.extend(request, params))
        return self.parse_trades(trades, market, since, limit)

    async def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        market = None
        if symbol is not None:
            market = self.market(symbol)
        pair = market['id'] if market else 'all'
        request = {'currencyPair': pair}
        if since is not None:
            request['start'] = int(since / 1000)
            request['end'] = self.seconds() + 1  # adding 1 is a fix for  #3411
        # limit is disabled(does not really work as expected)
        if limit is not None:
            request['limit'] = int(limit)
        response = await self.privatePostReturnTradeHistory(self.extend(request, params))
        result = []
        if market is not None:
            result = self.parse_trades(response, market)
        else:
            if response:
                ids = list(response.keys())
                for i in range(0, len(ids)):
                    id = ids[i]
                    market = None
                    if id in self.markets_by_id:
                        market = self.markets_by_id[id]
                        trades = self.parse_trades(response[id], market)
                        for j in range(0, len(trades)):
                            result.append(trades[j])
                    else:
                        baseId, quoteId = id.split('_')
                        base = self.common_currency_code(baseId)
                        quote = self.common_currency_code(quoteId)
                        symbol = base + '/' + quote
                        trades = response[id]
                        for j in range(0, len(trades)):
                            result.append(self.extend(self.parse_trade(trades[j]), {
                                'symbol': symbol,
                            }))
        return self.filter_by_since_limit(result, since, limit)

    def parse_order(self, order, market=None):
        timestamp = self.safe_integer(order, 'timestamp')
        if not timestamp:
            timestamp = self.parse8601(order['date'])
        trades = None
        if 'resultingTrades' in order:
            trades = self.parse_trades(order['resultingTrades'], market)
        symbol = None
        if market:
            symbol = market['symbol']
        price = self.safe_float(order, 'price')
        remaining = self.safe_float(order, 'amount')
        amount = self.safe_float(order, 'startingAmount', remaining)
        filled = None
        cost = 0
        if amount is not None:
            if remaining is not None:
                filled = amount - remaining
                if price is not None:
                    cost = filled * price
        if filled is None:
            if trades is not None:
                filled = 0
                cost = 0
                for i in range(0, len(trades)):
                    trade = trades[i]
                    tradeAmount = trade['amount']
                    tradePrice = trade['price']
                    filled = self.sum(filled, tradeAmount)
                    cost += tradePrice * tradeAmount
        return {
            'info': order,
            'id': order['orderNumber'],
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': order['status'],
            'symbol': symbol,
            'type': order['type'],
            'side': order['side'],
            'price': price,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'trades': trades,
            'fee': None,
        }

    def parse_open_orders(self, orders, market, result):
        for i in range(0, len(orders)):
            order = orders[i]
            extended = self.extend(order, {
                'status': 'open',
                'type': 'limit',
                'side': order['type'],
                'price': order['rate'],
            })
            result.append(self.parse_order(extended, market))
        return result

    async def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        market = None
        if symbol is not None:
            market = self.market(symbol)
        pair = market['id'] if market else 'all'
        response = await self.privatePostReturnOpenOrders(self.extend({
            'currencyPair': pair,
        }))
        openOrders = []
        if market is not None:
            openOrders = self.parse_open_orders(response, market, openOrders)
        else:
            marketIds = list(response.keys())
            for i in range(0, len(marketIds)):
                marketId = marketIds[i]
                orders = response[marketId]
                m = self.markets_by_id[marketId]
                openOrders = self.parse_open_orders(orders, m, openOrders)
        for j in range(0, len(openOrders)):
            self.orders[openOrders[j]['id']] = openOrders[j]
        openOrdersIndexedById = self.index_by(openOrders, 'id')
        cachedOrderIds = list(self.orders.keys())
        result = []
        for k in range(0, len(cachedOrderIds)):
            id = cachedOrderIds[k]
            if id in openOrdersIndexedById:
                self.orders[id] = self.extend(self.orders[id], openOrdersIndexedById[id])
            else:
                order = self.orders[id]
                if order['status'] == 'open':
                    order = self.extend(order, {
                        'status': 'closed',
                        'cost': None,
                        'filled': order['amount'],
                        'remaining': 0.0,
                    })
                    if order['cost'] is None:
                        if order['filled'] is not None:
                            order['cost'] = order['filled'] * order['price']
                    self.orders[id] = order
            order = self.orders[id]
            if market is not None:
                if order['symbol'] == symbol:
                    result.append(order)
            else:
                result.append(order)
        return self.filter_by_since_limit(result, since, limit)

    async def fetch_order(self, id, symbol=None, params={}):
        since = self.safe_value(params, 'since')
        limit = self.safe_value(params, 'limit')
        request = self.omit(params, ['since', 'limit'])
        orders = await self.fetch_orders(symbol, since, limit, request)
        for i in range(0, len(orders)):
            if orders[i]['id'] == id:
                return orders[i]
        raise OrderNotCached(self.id + ' order id ' + str(id) + ' is not in "open" state and not found in cache')

    def filter_orders_by_status(self, orders, status):
        result = []
        for i in range(0, len(orders)):
            if orders[i]['status'] == status:
                result.append(orders[i])
        return result

    async def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        orders = await self.fetch_orders(symbol, since, limit, params)
        return self.filter_orders_by_status(orders, 'open')

    async def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        orders = await self.fetch_orders(symbol, since, limit, params)
        return self.filter_orders_by_status(orders, 'closed')

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        if type == 'market':
            raise ExchangeError(self.id + ' allows limit orders only')
        await self.load_markets()
        method = 'privatePost' + self.capitalize(side)
        market = self.market(symbol)
        request = {
            'currencyPair': market['id'],
            'rate': self.price_to_precision(symbol, price),
            'amount': self.amount_to_precision(symbol, amount),
        }
        response = await getattr(self, method)(self.extend(request, params))
        timestamp = self.milliseconds()
        order = self.parse_order(self.extend({
            'timestamp': timestamp,
            'status': 'open',
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
        }, response), market)
        id = order['id']
        self.orders[id] = order
        return self.extend({'info': response}, order)

    async def edit_order(self, id, symbol, type, side, amount, price=None, params={}):
        await self.load_markets()
        price = float(price)
        request = {
            'orderNumber': id,
            'rate': self.price_to_precision(symbol, price),
        }
        if amount is not None:
            request['amount'] = self.amount_to_precision(symbol, amount)
        response = await self.privatePostMoveOrder(self.extend(request, params))
        result = None
        if id in self.orders:
            self.orders[id]['status'] = 'canceled'
            newid = response['orderNumber']
            self.orders[newid] = self.extend(self.orders[id], {
                'id': newid,
                'price': price,
                'status': 'open',
            })
            if amount is not None:
                self.orders[newid]['amount'] = amount
            result = self.extend(self.orders[newid], {'info': response})
        else:
            market = None
            if symbol is not None:
                market = self.market(symbol)
            result = self.parse_order(response, market)
            self.orders[result['id']] = result
        return result

    async def cancel_order(self, id, symbol=None, params={}):
        await self.load_markets()
        response = None
        try:
            response = await self.privatePostCancelOrder(self.extend({
                'orderNumber': id,
            }, params))
        except Exception as e:
            if isinstance(e, CancelPending):
                # A request to cancel the order has been sent already.
                # If we then attempt to cancel the order the second time
                # before the first request is processed the exchange will
                # raise a CancelPending exception. Poloniex won't show the
                # order in the list of active(open) orders and the cached
                # order will be marked as 'closed'(see  #1801 for details).
                # To avoid that we proactively mark the order as 'canceled'
                # here. If for some reason the order does not get canceled
                # and still appears in the active list then the order cache
                # will eventually get back in sync on a call to `fetchOrder`.
                if id in self.orders:
                    self.orders[id]['status'] = 'canceled'
            raise e
        if id in self.orders:
            self.orders[id]['status'] = 'canceled'
        return response

    async def fetch_order_status(self, id, symbol=None, params={}):
        await self.load_markets()
        orders = await self.fetch_open_orders(symbol, None, None, params)
        indexed = self.index_by(orders, 'id')
        return 'open' if (id in list(indexed.keys())) else 'closed'

    async def fetch_order_trades(self, id, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        trades = await self.privatePostReturnOrderTrades(self.extend({
            'orderNumber': id,
        }, params))
        return self.parse_trades(trades)

    async def create_deposit_address(self, code, params={}):
        await self.load_markets()
        currency = self.currency(code)
        response = await self.privatePostGenerateNewAddress({
            'currency': currency['id'],
        })
        address = None
        tag = None
        if response['success'] == 1:
            address = self.safe_string(response, 'response')
        self.check_address(address)
        depositAddress = self.safe_string(currency['info'], 'depositAddress')
        if depositAddress is not None:
            tag = address
            address = depositAddress
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'info': response,
        }

    async def fetch_deposit_address(self, code, params={}):
        await self.load_markets()
        currency = self.currency(code)
        response = await self.privatePostReturnDepositAddresses()
        currencyId = currency['id']
        address = self.safe_string(response, currencyId)
        tag = None
        self.check_address(address)
        depositAddress = self.safe_string(currency['info'], 'depositAddress')
        if depositAddress is not None:
            tag = address
            address = depositAddress
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'info': response,
        }

    async def withdraw(self, code, amount, address, tag=None, params={}):
        self.check_address(address)
        await self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
            'amount': amount,
            'address': address,
        }
        if tag:
            request['paymentId'] = tag
        result = await self.privatePostWithdraw(self.extend(request, params))
        return {
            'info': result,
            'id': result['response'],
        }

    async def fetch_transactions_helper(self, code=None, since=None, limit=None, params={}):
        await self.load_markets()
        year = 31104000  # 60 * 60 * 24 * 30 * 12 = one year of history, why not
        now = self.seconds()
        start = int(since / 1000) if (since is not None) else now - year
        request = {
            'start': start,  # UNIX timestamp, required
            'end': now,  # UNIX timestamp, required
        }
        if limit is not None:
            request['limit'] = limit
        response = await self.privatePostReturnDepositsWithdrawals(self.extend(request, params))
        #
        #     {   deposits: [{     currency: "BTC",
        #                              address: "1MEtiqJWru53FhhHrfJPPvd2tC3TPDVcmW",
        #                               amount: "0.01063000",
        #                        confirmations:  1,
        #                                 txid: "952b0e1888d6d491591facc0d37b5ebec540ac1efb241fdbc22bcc20d1822fb6",
        #                            timestamp:  1507916888,
        #                               status: "COMPLETE"                                                          },
        #                      {     currency: "ETH",
        #                              address: "0x20108ba20b65c04d82909e91df06618107460197",
        #                               amount: "4.00000000",
        #                        confirmations:  38,
        #                                 txid: "0x4be260073491fe63935e9e0da42bd71138fdeb803732f41501015a2d46eb479d",
        #                            timestamp:  1525060430,
        #                               status: "COMPLETE"                                                            }  ],
        #       withdrawals: [{withdrawalNumber:  8224394,
        #                                currency: "EMC2",
        #                                 address: "EYEKyCrqTNmVCpdDV8w49XvSKRP9N3EUyF",
        #                                  amount: "63.10796020",
        #                                     fee: "0.01000000",
        #                               timestamp:  1510819838,
        #                                  status: "COMPLETE: d37354f9d02cb24d98c8c4fc17aa42f475530b5727effdf668ee5a43ce667fd6",
        #                               ipAddress: "5.220.220.200"                                                               },
        #                      {withdrawalNumber:  9290444,
        #                                currency: "ETH",
        #                                 address: "0x191015ff2e75261d50433fbd05bd57e942336149",
        #                                  amount: "0.15500000",
        #                                     fee: "0.00500000",
        #                               timestamp:  1514099289,
        #                                  status: "COMPLETE: 0x12d444493b4bca668992021fd9e54b5292b8e71d9927af1f076f554e4bea5b2d",
        #                               ipAddress: "5.228.227.214"                                                                 },
        #                      {withdrawalNumber:  11518260,
        #                                currency: "BTC",
        #                                 address: "8JoDXAmE1GY2LRK8jD1gmAmgRPq54kXJ4t",
        #                                  amount: "0.20000000",
        #                                     fee: "0.00050000",
        #                               timestamp:  1527918155,
        #                                  status: "COMPLETE: 1864f4ebb277d90b0b1ff53259b36b97fa1990edc7ad2be47c5e0ab41916b5ff",
        #                               ipAddress: "211.8.195.26"                                                                }    ]}
        #
        return response

    async def fetch_transactions(self, code=None, since=None, limit=None, params={}):
        response = await self.fetch_transactions_helper(code, since, limit, params)
        for i in range(0, len(response['deposits'])):
            response['deposits'][i]['type'] = 'deposit'
        for i in range(0, len(response['withdrawals'])):
            response['withdrawals'][i]['type'] = 'withdrawal'
        withdrawals = self.parseTransactions(response['withdrawals'], code, since, limit)
        deposits = self.parseTransactions(response['deposits'], code, since, limit)
        transactions = self.array_concat(deposits, withdrawals)
        return self.filterByCurrencySinceLimit(self.sort_by(transactions, 'timestamp'), code, since, limit)

    async def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        response = await self.fetch_transactions_helper(code, since, limit, params)
        for i in range(0, len(response['withdrawals'])):
            response['withdrawals'][i]['type'] = 'withdrawal'
        withdrawals = self.parseTransactions(response['withdrawals'], code, since, limit)
        return self.filterByCurrencySinceLimit(withdrawals, code, since, limit)

    async def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        response = await self.fetch_transactions_helper(code, since, limit, params)
        for i in range(0, len(response['deposits'])):
            response['deposits'][i]['type'] = 'deposit'
        deposits = self.parseTransactions(response['deposits'], code, since, limit)
        return self.filterByCurrencySinceLimit(deposits, code, since, limit)

    def parse_transaction_status(self, status):
        statuses = {
            'COMPLETE': 'ok',
        }
        return self.safe_string(statuses, status, status)

    def parse_transaction(self, transaction, currency=None):
        #
        # deposits
        #
        #      {     currency: "BTC",
        #              address: "1MEtiqJWru53FhhHrfJPPvd2tC3TPDVcmW",
        #               amount: "0.01063000",
        #        confirmations:  1,
        #                 txid: "6b2b0e1888d6d491591facc0d37b5ebec540ac1efb241fdbc22bcc20d1822fb6",
        #            timestamp:  1507916888,
        #               status: "COMPLETE"                                                          }
        #
        # withdrawals
        #
        #      {withdrawalNumber:  9290444,
        #                currency: "ETH",
        #                 address: "0x731015ff2e75261d50433fbd05bd57e942336149",
        #                  amount: "0.15500000",
        #                     fee: "0.00500000",
        #               timestamp:  1514099289,
        #                  status: "COMPLETE: 0x74d444493b4bca668992021fd9e54b5292b8e71d9927af1f076f554e4bea5b2d",
        #               ipAddress: "5.228.227.214"                                                                 },
        #
        timestamp = self.safe_integer(transaction, 'timestamp')
        if timestamp is not None:
            timestamp = timestamp * 1000
        code = None
        currencyId = self.safe_string(transaction, 'currency')
        currency = self.safe_value(self.currencies_by_id, currencyId)
        if currency is None:
            code = self.common_currency_code(currencyId)
        if currency is not None:
            code = currency['code']
        status = self.safe_string(transaction, 'status', 'pending')
        txid = self.safe_string(transaction, 'txid')
        if status is not None:
            parts = status.split(': ')
            numParts = len(parts)
            status = parts[0]
            if (numParts > 1) and(txid is None):
                txid = parts[1]
            status = self.parse_transaction_status(status)
        id = self.safe_string(transaction, 'withdrawalNumber')
        type = 'withdrawal' if (id is not None) else 'deposit'
        amount = self.safe_float(transaction, 'amount')
        address = self.safe_string(transaction, 'address')
        feeCost = self.safe_float(transaction, 'fee')
        if feeCost is None:
            if type == 'deposit':
                # according to https://poloniex.com/fees/
                feeCost = 0  # FIXME: remove hardcoded value that may change any time
            elif type == 'withdrawal':
                raise ExchangeError('Withdrawal without fee detectednot ')
        return {
            'info': transaction,
            'id': id,
            'currency': code,
            'amount': amount,
            'address': address,
            'tag': None,
            'status': status,
            'type': type,
            'updated': None,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'fee': {
                'currency': code,
                'cost': feeCost,
            },
        }

    def nonce(self):
        return self.milliseconds()

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'][api]
        query = self.extend({'command': path}, params)
        if api == 'public':
            url += '?' + self.urlencode(query)
        else:
            self.check_required_credentials()
            query['nonce'] = self.nonce()
            body = self.urlencode(query)
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': self.apiKey,
                'Sign': self.hmac(self.encode(body), self.encode(self.secret), hashlib.sha512),
            }
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body):
        response = None
        try:
            response = json.loads(body)
        except Exception as e:
            # syntax error, resort to default error handler
            return
        # {"error":"Permission denied."}
        if 'error' in response:
            message = response['error']
            feedback = self.id + ' ' + self.json(response)
            exact = self.exceptions['exact']
            if message in exact:
                raise exact[message](feedback)
            broad = self.exceptions['broad']
            broadKey = self.findBroadlyMatchedKey(broad, message)
            if broadKey is not None:
                raise broad[broadKey](feedback)
            raise ExchangeError(feedback)  # unknown message

    def _websocket_generate_url_stream(self, events, options):
        # streamList = []
        # for i in range(0, len(events)):
        #     element = events[i]
        #     params = {
        #         'event': element['event'],
        #         'symbol': self._websocket_market_id(element['symbol']),
        #     }
        #     streamGenerator = self.wsconf['events'][element['event']]['conx-param']['stream']
        #     streamList.append(self.implode_params(streamGenerator, params))
        #}
        # stream = '/'.join(streamList)
        return options['url']

    def _websocket_market_id(self, symbol):
        return self.market_id(symbol).lower()

    def _websocket_on_message(self, contextId, data):
        msg = json.loads(data)
        channelId = msg[0]
        if channelId == 1000:
            # account notification(beta)
            print('notification')
        elif channelId == 1002:
            # ticker data
            print('ticker')
        elif channelId == 1003:
            # 24 hour exchange volume
            print('24 hour exchange volume')
        elif channelId == 1010:
            print(self.id + '._websocketOnMessage() heartbeat ' + data)
        else:
            # if channelId is not one of the above, check if it is a marketId
            symbol = str(self.find_symbol(channelId))
            if symbol == str(channelId):
                # Some error occured
                self.emit('err', ExchangeError(self.id + '._websocketOnMessage() failed to get symbol for channelId: ' + channelId))
                self.websocketClose(contextId)
            else:
                self._websocket_handle_ob(contextId, msg)

    def _websocket_handle_ob(self, contextId, data):
        # Poloniex calls self Price Aggregated Book
        channelId = data[0]
        sequenceNumber = data[1]
        if len(data) > 2:
            orderbook = data[2]
            symbol = str(self.find_symbol(channelId))
            symbolData = self._contextGetSymbolData(contextId, 'ob', symbol)
            # Check if self is the first response which contains full current orderbook
            if orderbook[0][0] == 'i':
                # currencyPair = orderbook[0][1]['currencyPair']
                fullOrderbook = orderbook[0][1]['orderBook']
                asks = []
                bids = []
                keys = []
                i = 0
                keys = list(fullOrderbook[0].keys())
                for i in range(0, len(keys)):
                    asks.append([float(keys[i]), float(fullOrderbook[0][keys[i]])])
                keys = list(fullOrderbook[1].keys())
                for i in range(0, len(keys)):
                    bids.append([float(keys[i]), float(fullOrderbook[1][keys[i]])])
                fullOrderbook = {
                    'asks': asks,
                    'bids': bids,
                    'isFrozen': 0,
                    'seq': sequenceNumber,
                }
                # I decided not to push the initial orderbook to cache.
                # This way is less consistent but I think it's easier.
                fullOrderbook = self.parse_order_book(fullOrderbook)
                fullOrderbook = self._cloneOrderBook(fullOrderbook, symbolData['limit'])
                fullOrderbook['obLastSequenceNumber'] = sequenceNumber
                symbolData['ob'] = fullOrderbook
                self._contextSetSymbolData(contextId, 'ob', symbol, symbolData)
                self.emit('ob', symbol, symbolData['ob'])
            else:
                order = None
                orderbookDelta = {
                    'asks': [],
                    'bids': [],
                    'seq': sequenceNumber,
                }
                price = 0.0
                amount = 0.0
                i = 0
                for i in range(0, len(orderbook)):
                    order = orderbook[i]
                    if order[0] == 'o':
                        price = float(order[2])
                        amount = float(order[3])
                        if order[1] == 0:
                            # sell order
                            orderbookDelta['asks'].append([price, amount])
                        elif order[1] == 1:
                            # buy order
                            orderbookDelta['bids'].append([price, amount])
                        else:
                            # error
                            self.emit('err', ExchangeError(self.id + '._websocketHandleOb() unknown value in buy/sell field. Expected 0 or 1 but got: ' + order[1]))
                            self.websocketClose(contextId)
                            return
                    elif order[0] == 't':
                        # self is not an order but a trade
                        print(self.id + '._websocketHandleOb() skipping trade.')
                        continue
                    else:
                        # unknown value
                        self.emit('err', ExchangeError(self.id + '._websocketHandleOb() unknown value in order/trade field. Expected \'o\' or \'t\' but got: ' + order[0]))
                        self.websocketClose(contextId)
                        return
                # Add to cache
                orderbookDelta = self.parse_order_book(orderbookDelta)
                if (symbolData['obDeltaCache']) is None:
                    # This check is necessary because the obDeltaCache will be deleted on a call to fetchOrderBook()
                    symbolData['obDeltaCache'] = {}  # make empty cache
                    symbolData['obDeltaCacheSize'] = 0  # counting number of cached deltas
                symbolData['obDeltaCacheSize'] += 1
                sequenceNumberStr = str(sequenceNumber)
                symbolData['obDeltaCache'][sequenceNumberStr] = orderbookDelta
                # Schedule call to _websocketOrderBookDeltaCache()
                self._websocket_handle_ob_delta_cache(contextId, symbol)
                self.emit('ob', symbol, symbolData['ob'])

    def _websocket_handle_ob_delta_cache(self, contextId, symbol):
        symbolData = self._contextGetSymbolData(contextId, 'ob', symbol)
        # Handle out-of-order sequenceNumber
        # To avoid a memory leak, we must put a maximum on the size of obDeltaCache.
        # When self maximum is reached, we accept that we have lost some orderbook updates.
        # In self case we must fetch a new orderbook.
        # Alternatively, we could apply all cached deltas and keep going.
        if symbolData['obDeltaCacheSize'] > symbolData['obDeltaCacheSizeMax']:
            symbolData['ob'] = self.fetch_order_book(symbol, symbolData['limit'])
            # delete symbolData['obDeltaCache']
            symbolData['obDeltaCache'] = None
            symbolData['obDeltaCacheSize'] = 0
            self._contextSetSymbolData(contextId, 'ob', symbol, symbolData)
            return
        if symbolData['obDeltaCacheSize'] == 0:
            self._contextSetSymbolData(contextId, 'ob', symbol, symbolData)
            return
        # if the cache exists
        # check if the next sequenceNumber is in the cache
        fullOrderbook = symbolData['ob']
        lastSequenceNumber = fullOrderbook['obLastSequenceNumber']
        cachedSequenceNumber = lastSequenceNumber + 1
        cachedSequenceNumberStr = str(cachedSequenceNumber)
        orderbookDelta = symbolData['obDeltaCache'][cachedSequenceNumberStr]
        continueBool = orderbookDelta is not None
        # While loop is not transpiled properly
        # while(continueBool) {
        nkeys = symbolData['obDeltaCacheSize']
        i = 0
        for i in range(0, nkeys):
            if not continueBool:
                break
            symbolData['obDeltaCache'][cachedSequenceNumberStr] = None
            fullOrderbook = self.mergeOrderBookDelta(symbolData['ob'], orderbookDelta)
            fullOrderbook = self._cloneOrderBook(fullOrderbook, symbolData['limit'])
            fullOrderbook['obLastSequenceNumber'] = cachedSequenceNumber
            symbolData['ob'] = fullOrderbook
            cachedSequenceNumber += 1
            orderbookDelta = symbolData['obDeltaCache'][cachedSequenceNumberStr]
            continueBool = orderbookDelta is not None
            symbolData['obDeltaCacheSize'] -= 1
        self._contextSetSymbolData(contextId, 'ob', symbol, symbolData)

    def _websocket_subscribe_ob(self, contextId, event, symbol, nonce, params={}):
        symbolData = self._contextGetSymbolData(contextId, 'ob', symbol)
        symbolData['limit'] = self.safe_integer(params, 'limit', None)
        symbolData['obDeltaCache'] = None
        symbolData['obDeltaCacheSize'] = 0
        symbolData['obDeltaCacheSizeMax'] = self.safe_integer(params, 'obDeltaCacheSizeMax', 10)
        self._contextSetSymbolData(contextId, 'ob', symbol, symbolData)
        #
        market = self.market_id(symbol)
        #
        payload = {
            'command': 'subscribe',
            'channel': market,
        }
        nonceStr = str(nonce)
        self.emit(nonceStr, True)
        self.websocketSendJson(payload)

    def _websocket_subscribe(self, contextId, event, symbol, nonce, params={}):
        if event == 'ob':
            self._websocket_subscribe_ob(contextId, event, symbol, nonce, params)
        else:
            raise NotSupported('subscribe ' + event + '(' + symbol + ') not supported for exchange ' + self.id)

    def _websocket_unsubscribe_ob(self, conxid, event, symbol, nonce, params):
        market = self.market_id(symbol)
        payload = {
            'command': 'unsubscribe',
            'channel': market,
        }
        nonceStr = str(nonce)
        self.emit(nonceStr, True)
        self.websocketSendJson(payload)

    def _websocket_unsubscribe(self, conxid, event, symbol, nonce, params):
        if event == 'ob':
            self._websocket_unsubscribe_ob(conxid, event, symbol, nonce, params)
        else:
            raise NotSupported('subscribe ' + event + '(' + symbol + ') not supported for exchange ' + self.id)

    def _get_current_websocket_orderbook(self, contextId, symbol, limit):
        data = self._contextGetSymbolData(contextId, 'ob', symbol)
        if ('ob' in list(data.keys())) and(data['ob'] is not None):
            return self._cloneOrderBook(data['ob'], limit)
        return None
